package lack.meta.core.target

import lack.meta.base.{names, pretty}
import lack.meta.base.names.given

import lack.meta.core.target.c.{Printer => P}

import lack.meta.core.Sort
import lack.meta.core.term
import lack.meta.core.term.{Exp, Val}
import lack.meta.core.node.{Node, Schedule, Variable}

import lack.meta.core.obc
import lack.meta.core.obc.Obc.{Statement, Method, Class}

import scala.collection.immutable.SortedMap

/** Translating from Obc to C */
object C:

  case class Options(
    basename: String,
    classes:  names.immutable.RefMap[Class],
    includes: List[String] = List("#include <lack.h>"),
    version: String = "v0", // TODO hook version numbers up to git and ci
    check: obc.Check.Options = obc.Check.Options()
  )

  def header(options: Options): pretty.Doc =
    prelude(options) <@>
    pretty.vsep(options.classes.values.map(Header.klass(_)).toSeq)

  def source(options: Options, selfInclude: Boolean = true): pretty.Doc =
    val includes =
      if selfInclude
      then options.includes ++ List(s"#include \"${options.basename}.h\"")
      else options.includes
    prelude(options.copy(includes = includes)) <@>
    pretty.vsep(options.classes.values.map(Source.klass(_, options)).toSeq)

  def prelude(options: Options): pretty.Doc =
    val text =
      s"${options.basename} generated by lack version ${options.version}"
    val txxt = text.map(c => '*')
    val lines = List(
      s"/***${txxt}**/",
      s"/** ${text} */",
      s"/***${txxt}**/",
      "") ++ options.includes ++ List("")
    pretty.vsep(lines.map(pretty.text(_)))

  object Names:
    def state(klass: names.Ref): names.Ref =
      P.Ident.suffix(klass, "state")
    def stateP(klass: names.Ref) = P.Ident.ref(state(klass))

    def out(name: names.Ref): names.Ref =
      P.Ident.suffix(name, "out")
    def outP(name: names.Ref) = P.Ident.ref(out(name))

  object Header:
    def state(k: Class): pretty.Doc =
      val objectsP = k.objects.map { case (k,v) =>
        P.Decl.var_(k, Names.state(v))
      }
      val fieldsP = k.fields.map { kv =>
        P.Decl.var_(kv.name, kv.sort)
      }

      P.Decl.struct(Names.state(k.name), objectsP ++ fieldsP)

    def method(k: Class, m: Method): pretty.Doc =
      val name = names.Ref(k.name.fullyQualifiedPath, m.name)

      val (struct_decl, ret_ty, ret_args) = m.returns match
        case List() => (List(), P.Type.void, List())
        case rets =>
          // TODO sneaky invariant mode declare nested fields here
          val fieldsP = rets.map { kv =>
            P.Decl.var_(kv.name, kv.sort)
          }
          val out = P.Decl.struct(Names.out(name), fieldsP)
          (List(out), P.Type.void, List(P.Type.ptr(Names.outP(name))))

      val argsP =
        P.Type.ptr(Names.stateP(k.name)) ::
          m.params.map { kv => P.Type.sort(kv.sort) <+> P.Ident.component(kv.name) } ++
          ret_args

      pretty.vsep(
        struct_decl ++
        List(P.Decl.fun(ret_ty, name, argsP))
      ) <> pretty.line

    def klass(k: Class): pretty.Doc =
      val methods = k.methods.map(method(k, _))
      state(k) <@>
        pretty.vsep(methods) <> pretty.line

  object Source:
    def freshen(base: String, used: List[names.Component]) =
      val baseS = base
      val usedS = used.map(P.Ident.componentString(_))
      if !usedS.contains(baseS)
      then pretty.text(baseS)
      else
        val fresh =
          for
            k <- 1 to 100
            baseK = baseS + "$" + k
            if !usedS.contains(baseK)
          yield pretty.text(baseK)
        fresh.headOption.getOrElse(
          throw new Exception(s"Can't generate free variable for ${base} in set ${usedS}"))

    def val_(v: Val): pretty.Doc = v match
      case Val.Bool(b) => b.toString
      case Val.Refined(s: Sort.BoundedInteger, Val.Int(i)) =>
        val suffix = (s.signed, s.width) match
          case (true,  64) => "ul"
          case (false, 64) => "l"
          case (true,  32) => "u"
          case (_,     _)  => ""
        pretty.value(i) <> suffix
      case Val.Real(r) => pretty.value(r)
      // TODO hmm
      case Val.Int(i) =>
        pretty.value(i)
      case _ =>
        throw new P.except.BigNumberException("value", v.ppr)

    def binop(prim: term.Prim): (String, Int) =
      import term.prim.Table._
      prim match
        case Or  => ("||", 12)
        case And => ("&&", 11)
        case Lt  => ("<",  6)
        case Le  => ("<=", 6)
        case Gt  => (">",  6)
        case Ge  => (">",  6)
        case Eq  => ("==", 6)
        case Add => ("+",  4)
        case Sub => ("-",  4)
        case Mul => ("*",  3)
        case Div => ("/",  3)
    val COMMA_PREC = 15
    val PARENS_PREC = 16

    //   10 +  2 * 5   < 10
    // ((10 + (2 * 5)) < 10)
    // a +  b + c
    // a + (b + c)
    def nest(self: pretty.Doc, e: Exp, p: Int, limit: Int) =
      if p <= limit
      then pretty.parens(exp(self, e, PARENS_PREC))
      else exp(self, e, p)

    def exp(self: pretty.Doc, e: Exp, p: Int): pretty.Doc = e match
      case Exp.Var(_, r) => r.prefix match
        case self_ :: rest
         if List(self_) == Class.self.prefix =>
          P.Term.fieldptr(self, P.Term.fields(rest, r.name))
        case _ =>
          P.Term.fields(r.prefix, r.name)
      case Exp.Val(v) => val_(v)

      // TODO: do we need to insert casts?
      case Exp.Cast(_, e) =>
        exp(self, e, p)

      case Exp.App(_, term.prim.Table.Negate, a) =>
        pretty.text("-") <> nest(self, a, p, 2)
      case Exp.App(_, term.prim.Table.Not, a) =>
        pretty.text("!") <> nest(self, a, p, 2)
      case Exp.App(_, term.prim.Table.Implies, a, b) =>
        P.Term.fun("lack_implies", List(exp(self, a, COMMA_PREC), exp(self, b, COMMA_PREC)))
      case Exp.App(_, op, a, b) =>
        val (o, pp) = binop(op)
        nest(self, a, p, pp) <+> o <+> nest(self, b, p, pp + 1)
      case Exp.App(_, term.prim.Table.Ite, pred, t, f) =>
        nest(self, pred, p, 13) <+> "?" <+>
          nest(self, t, p, 13) <+> ":" <+>
          nest(self, f, p, 13)
      case Exp.App(_, p, _ : _*) =>
        throw new Exception(s"prim not supported: ${p}")

    def exp(self: pretty.Doc, e: Exp): pretty.Doc = exp(self, e, PARENS_PREC)

    def statement(self: pretty.Doc, s: Statement, options: Options): pretty.Doc = s match
      case Statement.Skip =>
        pretty.emptyDoc
      case Statement.Seq(p, q) =>
        statement(self, p, options) <@>
          statement(self, q, options)
      case Statement.Assign(name, e) =>
        P.Stm.assign(P.Ident.component(name), exp(self, e))
      case Statement.AssignSelf(name, e) =>
        P.Stm.assign(P.Term.fieldptr(self, name), exp(self, e))
      case Statement.Ite(p, t, f) =>
        val else_ = f match
          case Statement.Skip => None
          case _ => Some(statement(self, f, options))
        P.Stm.if_(exp(self, p), statement(self, t, options), else_)

      case Statement.Call(assigns, klass, method, instance, args) =>
        val name  = names.Ref(klass.fullyQualifiedPath, method)
        val instP = P.Term.address(P.Term.fieldptr(self, instance))
        val argsP = args.map(exp(self, _))
        val outT = Names.outP(name)
        val outV = P.Ident.component(instance)
        val meth = options.classes(klass).methodsMap(method)
        (assigns, meth.returns) match
          case (None, List()) =>
            P.Stm.fun(name, instP :: argsP)
          case (Some(_), List()) =>
            P.Stm.fun(name, instP :: argsP)
          case (None, _ :: _) =>
            val discard = pretty.text("$$discard")
            P.Stm.block(
              outT <+> discard <> pretty.semi <@>
              P.Stm.fun(name, instP +: argsP :+ discard)
            )
          case (Some(storage), _ :: _) =>
            P.Stm.fun(name, instP +: argsP :+ P.Term.address(P.Ident.component(storage)))



    def method(k: Class, m: Method, options: Options): pretty.Doc =
      val name = names.Ref(k.name.fullyQualifiedPath, m.name)
      val used = (m.params ++ m.returns ++ m.locals).map(_.name) ++ m.storage.map(_.name)
      val self = freshen("self", used)
      val out  = freshen("out", used)

      val (ret_ty, ret_args, ret_stms) = m.returns match
        case List() =>
          (P.Type.void, List(), List())
        case rets =>
          val stms = rets.map { r =>
            P.Stm.assign(P.Term.fieldptr(out, r.name), P.Ident.component(r.name))
          }
          (P.Type.void, List(P.Type.ptr(Names.outP(name)) <+> out), stms)

      val argsP =
        (P.Type.ptr(Names.stateP(k.name)) <+> self) ::
          m.params.map { kv => P.Type.sort(kv.sort) <+> P.Ident.component(kv.name) } ++
          ret_args

      val locals = (m.locals ++ m.returns).map { case kv =>
        P.Decl.var_(kv.name, kv.sort)
      }
      val storage = m.storage.map { case s =>
        val out = Names.outP(names.Ref(s.klass.fullyQualifiedPath, s.method))
        P.Decl.var_(s.name, out)
      }

      val stms =
        locals ++
        storage ++
        List(Source.statement(self, m.body, options)) ++
        ret_stms

      ret_ty <+> P.Ident.ref(name) <> pretty.tuple(argsP) <>
        P.Stm.block(pretty.vsep(stms)) <>
        pretty.line

    def klass(k: Class, options: Options): pretty.Doc =
      val methods = k.methods.map(method(k, _, options))
      pretty.vsep(methods)
